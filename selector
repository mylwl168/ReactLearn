
async function getChromeFullPathSelector(locator) {
  async function getChromeFullPathSelector(locator) {
    const elementHandle = await locator.elementHandle();
    if (!elementHandle) {
        throw new Error('Locator 未定位到任何元素');
    }

    const selector = await elementHandle.evaluate((element) => {
        function buildSelector(el) {
            if (!el || el.id === 'root') {
                return '#root'; // 起点为 #root
            }

            const tagName = el.tagName.toLowerCase();
            const id = el.id;
            const parent = el.parentElement;

            // ID 优先
            if (id) {
                return `${buildSelector(parent)} > #${id}`;
            }

            // 获取所有同标签名的兄弟元素
            const siblings = Array.from(parent.children).filter(
                child => child.tagName.toLowerCase() === tagName
            );
            const isUniqueTag = siblings.length === 1;

            // 获取类名
            const classList = Array.from(el.classList);
            const hasUnderscoreClass = classList.some(cls => cls.startsWith('_'));
            const classString = classList.join('.');

            // 如果标签唯一且无下划线开头的类名，使用标签名
            if (isUniqueTag && !hasUnderscoreClass) {
                return `${buildSelector(parent)} > ${tagName}`;
            }

            // 如果有类名且不以下划线开头，保留所有类
            if (classString && !hasUnderscoreClass) {
                return `${buildSelector(parent)} > ${tagName}.${classString}`;
            }

            // 无 ID 或类名以下划线开头或标签非唯一，使用 nth-child
            const index = siblings.indexOf(el) + 1;
            return `${buildSelector(parent)} > ${tagName}:nth-child(${index})`;
        }

        return buildSelector(element);
    });

    await elementHandle.dispose();
    return selector;
}

// 示例用法
const { chromium } = require('playwright');
(async () => {
    const browser = await chromium.launch();
    const page = await browser.newPage();
    await page.setContent(`
        <div id="root">
            <div class="container">
                <form>
                    <label class="_hidden"><input type="text"></label>
                    <label><input type="checkbox"></label>
                </form>
                <ul>
                    <li class="_item">Item 1</li>
                    <li>Item 2</li>
                </ul>
                <button id="submit">Click</button>
            </div>
        </div>
    `);

    console.log(await getChromeFullPathSelector(page.locator('div.container')));          // 输出: #root > div
    console.log(await getChromeFullPathSelector(page.locator('form input').nth(0)));     // 输出: #root > div > form > label:nth-child(1) > input
    console.log(await getChromeFullPathSelector(page.locator('ul li').nth(0)));          // 输出: #root > div > ul > li:nth-child(1)
    console.log(await getChromeFullPathSelector(page.locator('#submit')));               // 输出: #root > div > #submit

    await browser.close();
})();










// utils/selectorGenerator.ts
export const getChromeSelector = async (element: Locator): Promise<string> => {
  return element.evaluate((el) => {
    const getPath = (node: Element): string => {
      if (node.id) return `#${node.id}`;
      if (node === document.body) return 'body';

      const parent = node.parentElement;
      if (!parent) return node.tagName.toLowerCase();

      // 生成当前节点的选择器部分
      let currentSelector = node.tagName.toLowerCase();

      // 附加所有非空类名（即使唯一）
      const classes = Array.from(node.classList).filter(c => c.trim() !== '');
      if (classes.length > 0) {
        currentSelector += `.${classes.join('.')}`;
      } else {
        // 无类名时使用 nth-child
        const siblings = Array.from(parent.children).filter(child => 
          child.tagName === node.tagName
        );
        const index = siblings.indexOf(node) + 1;
        currentSelector += `:nth-child(${index})`;
      }

      // 递归父节点
      return `${getPath(parent)} > ${currentSelector}`;
    };

    return getPath(el);
  });
};







// utils/selectorGenerator.ts
export const getChromeSelector = async (element: Locator): Promise<string> => {
  return element.evaluate((el) => {
    const getPath = (node: Element): string => {
      if (node.id) return `#${node.id}`;
      if (node === document.body) return 'body';

      const parent = node.parentElement;
      if (!parent) return node.nodeName.toLowerCase();

      // 获取元素在父节点中的位置（忽略文本节点）
      const siblings = Array.from(parent.children);
      const index = siblings.indexOf(node) + 1; // nth-child从1开始

      // 构建当前元素的选择器部分
      let selector = node.nodeName.toLowerCase();
      if (node.className) {
        const validClasses = node.className.split(/\s+/).filter(c => c.length > 0);
        if (validClasses.length > 0) {
          selector += `.${validClasses.join('.')}`;
        } else {
          selector += `:nth-child(${index})`;
        }
      } else {
        selector += `:nth-child(${index})`;
      }

      // 递归父节点并拼接路径
      return `${getPath(parent)} > ${selector}`;
    };

    return getPath(el);
  });
};



----

import { test, expect } from '@playwright/test';
import { getChromeSelector } from './utils/selectorGenerator';

test('获取元素选择器', async ({ page }) => {
  await page.goto('https://example.com');
  
  // 原始方式定位元素
  const element = page.locator('button >> text=Submit');
  
  // 调用函数获取选择器字符串
  const selector = await getChromeSelector(element);
  console.log('Selector:', selector); // 输出与Chrome一致的路径，如 "body > div#root > button.submit-btn"

  // 使用生成的选择器重新定位元素
  const sameElement = page.locator(selector);
  await expect(sameElement).toBeVisible();
});

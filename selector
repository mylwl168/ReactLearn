
async function getChromeSelector(locator) {
    // 获取 Playwright Locator 对应的元素句柄
    const elementHandle = await locator.elementHandle();
    if (!elementHandle) {
        throw new Error('Locator 未定位到任何元素');
    }

    // 在页面上下文中执行选择器生成逻辑
    const selector = await elementHandle.evaluate((element) => {
        // 获取标签名
        const tagName = element.tagName.toLowerCase();

        // 检查是否存在 ID，若有则优先返回 #id
        const id = element.id;
        if (id) {
            return `#${id}`;
        }

        // 获取类名并保留所有类
        const classList = Array.from(element.classList).join('.');
        if (classList) {
            return `${tagName}.${classList}`;
        }

        // 无 ID 和类名，计算 nth-child 索引
        const parent = element.parentElement;
        if (!parent) {
            return tagName; // 根元素直接返回标签名
        }

        const siblings = Array.from(parent.children).filter(
            child => child.tagName.toLowerCase() === tagName
        );
        const index = siblings.indexOf(element) + 1;

        // 递归获取父级选择器
        function getParentSelector(el) {
            const parentTag = el.tagName.toLowerCase();
            const parentId = el.id;
            if (parentId) {
                return `#${parentId}`;
            }
            const parentClass = Array.from(el.classList).join('.');
            if (parentClass) {
                return `${parentTag}.${parentClass}`;
            }
            if (!el.parentElement) {
                return parentTag;
            }
            return `${getParentSelector(el.parentElement)} > ${parentTag}`;
        }

        // 如果是唯一子元素，直接用标签名，否则用 nth-child
        if (siblings.length === 1) {
            return `${getParentSelector(parent)} > ${tagName}`;
        } else {
            return `${getParentSelector(parent)} > ${tagName}:nth-child(${index})`;
        }
    });

    await elementHandle.dispose(); // 释放句柄
    return selector;
}

// 示例用法
const { chromium } = require('playwright');
(async () => {
    const browser = await chromium.launch();
    const page = await browser.newPage();
    await page.setContent(`
        <div class="header"><span>Hello</span></div>
        <ul><li>Item 1</li><li>Item 2</li></ul>
        <button id="submit">Click</button>
    `);

    // 测试不同场景
    console.log(await getChromeSelector(page.locator('div.header')));        // 输出: div.header
    console.log(await getChromeSelector(page.locator('ul li').nth(0)));     // 输出: ul > li:nth-child(1)
    console.log(await getChromeSelector(page.locator('#submit')));          // 输出: #submit

    await browser.close();
})();















// utils/selectorGenerator.ts
export const getChromeSelector = async (element: Locator): Promise<string> => {
  return element.evaluate((el) => {
    const getPath = (node: Element): string => {
      if (node.id) return `#${node.id}`;
      if (node === document.body) return 'body';

      const parent = node.parentElement;
      if (!parent) return node.tagName.toLowerCase();

      // 生成当前节点的选择器部分
      let currentSelector = node.tagName.toLowerCase();

      // 附加所有非空类名（即使唯一）
      const classes = Array.from(node.classList).filter(c => c.trim() !== '');
      if (classes.length > 0) {
        currentSelector += `.${classes.join('.')}`;
      } else {
        // 无类名时使用 nth-child
        const siblings = Array.from(parent.children).filter(child => 
          child.tagName === node.tagName
        );
        const index = siblings.indexOf(node) + 1;
        currentSelector += `:nth-child(${index})`;
      }

      // 递归父节点
      return `${getPath(parent)} > ${currentSelector}`;
    };

    return getPath(el);
  });
};







// utils/selectorGenerator.ts
export const getChromeSelector = async (element: Locator): Promise<string> => {
  return element.evaluate((el) => {
    const getPath = (node: Element): string => {
      if (node.id) return `#${node.id}`;
      if (node === document.body) return 'body';

      const parent = node.parentElement;
      if (!parent) return node.nodeName.toLowerCase();

      // 获取元素在父节点中的位置（忽略文本节点）
      const siblings = Array.from(parent.children);
      const index = siblings.indexOf(node) + 1; // nth-child从1开始

      // 构建当前元素的选择器部分
      let selector = node.nodeName.toLowerCase();
      if (node.className) {
        const validClasses = node.className.split(/\s+/).filter(c => c.length > 0);
        if (validClasses.length > 0) {
          selector += `.${validClasses.join('.')}`;
        } else {
          selector += `:nth-child(${index})`;
        }
      } else {
        selector += `:nth-child(${index})`;
      }

      // 递归父节点并拼接路径
      return `${getPath(parent)} > ${selector}`;
    };

    return getPath(el);
  });
};



----

import { test, expect } from '@playwright/test';
import { getChromeSelector } from './utils/selectorGenerator';

test('获取元素选择器', async ({ page }) => {
  await page.goto('https://example.com');
  
  // 原始方式定位元素
  const element = page.locator('button >> text=Submit');
  
  // 调用函数获取选择器字符串
  const selector = await getChromeSelector(element);
  console.log('Selector:', selector); // 输出与Chrome一致的路径，如 "body > div#root > button.submit-btn"

  // 使用生成的选择器重新定位元素
  const sameElement = page.locator(selector);
  await expect(sameElement).toBeVisible();
});
